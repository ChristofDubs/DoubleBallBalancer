\documentclass{article}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{hyperref}

\begin{document}

\title{Double Ball Balancer}
\author{Christof Dubs}

\maketitle

\section{Introduction}

\section{Nomenclature}

\begin{itemize}
	\item{$a$: scalar $a \in \mathbb{R}$}
	\item{$\vec{a}$: vector $\vec{a} \in \mathbb{R}^3$}
	\item{${}_I \vec{a}$: vector $\vec{a}$, expressed in frame $I$}
	\item{${}^I \vec{e}_x$: x-axis of frame $I$}
	\item{${}_B^I \vec{e}_x$: x-axis of frame $I$, expressed in frame $B$}
	\item{$R_{IB}$: rotation matrix $\in \mathbb{R}^{3 \times 3}$ to transform the representation of a vector from frame $B$ to $I$: ${}_I \vec{a} =R_{IB} \cdot  {}_B \vec{a}$}
\end{itemize}
Note that $R_{IB}$ can not only be used to express vectors in different frames as in ${}_I^I \vec{e}_x =R_{IB} \cdot  {}_B^I \vec{e}_x$, but also to rotate vectors as in ${}_I^B \vec{e}_x =R_{IB} \cdot  {}_I^I \vec{e}_x$.

\section{Theory}

%Note that this is most straight-forward in the inertial frame: ${}_I \vec{v}_{OSi} = {}_I \left(\dot{\vec{r}}_{OSi} \right) = ({}_I \vec{r}_{OSi})^.$)

%\begin{equation}
%0 = \sum_{i=1}^n \left[{}_A J_{Si} \cdot {}_A \left(\dot{\vec{p}}_i \right) + {}_B J_{Ri} \cdot {}_B \left(\dot{\vec{N}}_{Si} \right) - {}_C J_{Pi} \cdot {}_C \vec{F}_i - {}_D J_{Ri} \cdot {}_D \vec{M}_i \right]
%\end{equation}

\section{2D version}
A simplified version of the double ball balancer is its two dimensional version, consisting of cylinders instead of spheres, and a single actuator.
This version has been developed for the following reasons:
\begin{itemize}
	\item Simpler and faster testing of different general concepts
	\item Improving the understanding of the more complex 3D version
	\item Potential re-usability of components
\end{itemize}

\subsection{State / Input definition}
The state of the 2D version is 6-dimensional; the following minimal coordinates are chosen:
\begin{itemize}
	\item $\beta$: rolling angle of upper ball [$rad$]
	\item $\dot{\beta}$: angular velocity of upper ball [$rad/s$]
	\item $\varphi$: angle of lever arm relative to inertial up direction [$rad$]
	\item $\dot{\varphi}$: angular velocity of lever arm relative to inertial up direction [$rad/s$]
	\item $\psi$: angle of contact point of upper ball on lower ball [$rad$]
	\item $\dot{\psi}$: angle derivative of contact point of upper ball on lower ball [$rad/s$]
\end{itemize}
Additionally, the following states are introduced and later eliminated during the derivation of the equations of motion:
\begin{itemize}
	\item $\alpha$: rolling angle of lower ball [$rad$]
	\item $\dot{\alpha}$: angular velocity of lower ball [$rad/s$]
	\item $\varphi_m$: motor angle [$rad$]
	\item $\dot{\varphi}_m$: motor angular velocity [$rad/s$]
	\item $x$: position of lower ball [$m$]
	\item $\dot{x}$: velocity  of lower ball [$m/s$]
\end{itemize}
To control the system, a simple speed-controller motor model will be used to make the motor follow an angular velocity command $\breve{\dot{\varphi}}_m$, which replaces the motor torque $T$.

\subsection{Parameter definition}
\begin{itemize}
	\item $l$ : Arm length of lever [$m$] (distance from rotation axis to center of mass)
	\item $m_1$: Mass of lower ball [$kg$]
	\item $m_2$: Mass of upper ball [$kg$]
	\item $m_3$: Mass of lever arm [$kg$]
	\item $r_1$: Radius of lower ball [$m$]
	\item $r_2$: Radius of upper ball [$m$]
	\item $\tau$: Time constant of speed-controlled motor [$s$]
	\item $\theta_1$: Mass moment of inertia of lower ball wrt. its center of mass [$kg*m^2$]
	\item $\theta_2$: Mass moment of inertia of upper ball wrt. its center of mass [$kg*m^2$]
	\item $\theta_3$: Mass moment of inertia of lever arm wrt. its center of mass [$kg*m^2$]
	\end{itemize}

\subsection{System description and kinematic relations}
In the following subsection, the position and linear / angular velocities of each rigid body is mathematically expressed. Kinematic relations (rolling constraints) are derived in order to later eliminate the states that are not part of the minimal coordinates.

\subsubsection{Lower ball state}
Position, velocity and angular velocity of the lower ball are given as per definition of the states:
\begin{equation}
{}_I \vec{r}_{OS1} = 
\left( {\begin{array}{c} x \\ r_1 \\ 0 \\ \end{array} } \right), \quad 
{}_I \vec{v}_{S1} = {}_I \dot{\vec{r}}_{OS1} =
\left( {\begin{array}{c} \dot{x} \\ 0 \\ 0 \\ \end{array} } \right), \quad 
{}_I \vec{\Omega}_1 = 
\left( {\begin{array}{c} 0 \\ 0 \\ \dot{\alpha} \\ \end{array} } \right)
\end{equation}
The external forces acting on the lower ball is the gravitational force:
\begin{equation}
{}_I \vec{F}_{1} = \left( {\begin{array}{c} 0 \\ -m_1 \cdot g \\ 0 \\ \end{array} } \right)
\end{equation}

\subsubsection{Rolling constraint: Lower ball on ground}
Consider point G which is the contact point of the lower ball on the ground:
\begin{equation}
{}_I \vec{r}_{S1G} = 
\left( {\begin{array}{c} 0 \\ -r_1 \\ 0 \\ \end{array} } \right)
\end{equation}
Momentarily, point G is both a point on the ball, as well as a point on the ground.
Since it is a point on the ground, its velocity is zero; and since it is part of the lower ball's rigid body, its velocity is
\begin{equation}
{}_I \vec{v}_{G} = {}_I \vec{v}_{S1} + {}_I \vec{\Omega}_1 \times {}_I \vec{r}_{S1G} =
\left( {\begin{array}{c} \dot{x} + r_1 \cdot \dot{\alpha} \\ 0 \\ 0 \\ \end{array} } \right) =
\left( {\begin{array}{c} 0 \\ 0 \\ 0 \\ \end{array} } \right)
\end{equation}
This leads to the following rolling constraint:
\begin{equation}
\dot{x} = -r_1 \cdot \dot{\alpha} \quad and \quad x = -r_1 \cdot \alpha
\end{equation}

\subsubsection{Upper ball state}
The angular velocity of the lower ball is given as per definition of the states:
\begin{equation}
{}_I \vec{\Omega}_2 = 
\left( {\begin{array}{c} 0 \\ 0 \\ \dot{\beta} \\ \end{array} } \right)
\end{equation}
The directional vector from lower to upper ball is
\begin{equation}
{}_I \vec{e}_{S1S2} = 
\left( {\begin{array}{c} -\sin{\psi} \\ \cos{\psi} \\ 0 \\ \end{array} } \right)
\end{equation}
and consequently, 
\begin{equation}
{}_I \vec{r}_{S1S2} = (r1+r2) \cdot {}_I \vec{e}_{S1S2} =
(r1+r2) \cdot \left( {\begin{array}{c} -\sin{\psi} \\ \cos{\psi} \\ 0 \\ \end{array} } \right)
\end{equation}
Finally,
\begin{equation}
{}_I \vec{r}_{OS2} = {}_I \vec{r}_{OS1} + {}_I \vec{r}_{S1S2} =
\left( {\begin{array}{c} x - (r1+r2) \cdot \sin{\psi} \\ r_1 + (r1+r2) \cdot \cos{\psi} \\ 0 \\ \end{array} } \right)
\end{equation} 
and
\begin{equation}
{}_I \vec{v}_{S2} = {}_I \dot{\vec{r}}_{OS2} =
\left( {\begin{array}{c} \dot{x} - (r1+r2) \cdot \dot{\psi} \cdot \cos{\psi} \\ - (r1+r2) \cdot \dot{\psi} \cdot \sin{\psi} \\ 0 \\ \end{array} } \right)
\end{equation} 
The external forces acting on the upper ball is the gravitational force:
\begin{equation}
{}_I \vec{F}_{2} = \left( {\begin{array}{c} 0 \\ -m_2 \cdot g \\ 0 \\ \end{array} } \right)
\end{equation}
From accelerating the lever arm through the motor, the upper ball feels the reaction torque
\begin{equation}
{}_I \vec{M}_{2} = \left( {\begin{array}{c} 0 \\ 0 \\ -T \\ \end{array} } \right)
\end{equation}

\subsubsection{Rolling constraint: Upper ball on lower ball}
Consider point P which is the contact point of the upper ball on the lower ball.
Since it is both part of upper and lower ball, the rolling constraint is given by
\begin{equation}
{}_I \vec{v}_{P} = {}_I \vec{v}_{S1} + {}_I \vec{\Omega}_1 \times {}_I \vec{r}_{S1P} =
{}_I \vec{v}_{S2} + {}_I \vec{\Omega}_2 \times {}_I \vec{r}_{S2P}
\end{equation}
where
\begin{equation}
{}_I \vec{r}_{S1P} = r1 \cdot {}_I \vec{e}_{S1S2} , \quad
{}_I \vec{r}_{S2P} = -r2 \cdot {}_I \vec{e}_{S1S2}
\end{equation}
This leads to
\begin{equation}
\dot{\alpha} = \left( 1+\frac{r_2}{r_1} \right) \cdot \dot{\psi} -\frac{r_2}{r_1}  \cdot \dot{\beta}
\end{equation}

\subsubsection{Lever arm}

The angular velocity of the lever arm is given as per definition of the states:
\begin{equation}
{}_I \vec{\Omega}_3 = 
\left( {\begin{array}{c} 0 \\ 0 \\ \dot{\phi} \\ \end{array} } \right)
\end{equation}
The vector from the upper ball's center to the center of mass of the lever arm is
\begin{equation}
{}_I \vec{r}_{S2S3} = 
l \cdot \left( {\begin{array}{c} \sin{\varphi} \\ -\cos{\varphi} \\ 0 \\ \end{array} } \right)
\end{equation}
The position of the center of mass of the lever arm is
\begin{equation}
{}_I \vec{r}_{OS3} = {}_I \vec{r}_{OS2} + {}_I \vec{r}_{S2S3} =
\left( {\begin{array}{c} x - (r1+r2) \cdot \sin{\psi} + l \cdot \sin{\varphi} \\ r_1 + (r1+r2) \cdot \cos{\psi} - l \cdot \cos{\varphi} \\ 0 \\ \end{array} } \right)
\end{equation} 
The external forces acting on the lever arm is the gravitational force:
\begin{equation}
{}_I \vec{F}_{3} = \left( {\begin{array}{c} 0 \\ -m_3 \cdot g \\ 0 \\ \end{array} } \right)
\end{equation}
From accelerating the lever arm through the motor, the upper ball feels the motor torque
\begin{equation}
{}_I \vec{M}_{3} = \left( {\begin{array}{c} 0 \\ 0 \\ T \\ \end{array} } \right)
\end{equation}
%and
%\begin{equation}
%{}_I \vec{v}_{S3} = {}_I \dot{\vec{r}}_{OS3} =
%\left( {\begin{array}{c} \dot{x} - (r1+r2) \cdot \dot{\psi} \cdot \cos{\psi} + l \dot{\varphi} \cdot \cos{\varphi} \\
%- (r1+r2) \cdot \dot{\psi} \cdot \sin{\psi} + l \dot{\varphi} \cdot \sin{\varphi}\\
%0 \\ \end{array} } \right)
%\end{equation} 

\subsection{Derivation of the equations of motion}
To derive the equations of motion, the concept of projected Newton-Euler equations is used, for which the following terms are needed:
For each rigid body $i$, 
\begin{enumerate}
	\item Express the position its center of mass ($\vec{r}_{OSi}$) and its angular velocity ($\vec{\omega}_i$) as a function of the minimal coordinates
	\item Formulate the all external forces $F_i$ and torques $M_i$
	\item Calculate the velocity of its center of mass ($\vec{v}_{OSi}$) as a function of the minimal coordinates using Euler's differentiation rule on $\vec{r}_{OSi}$
	\item Calculate the velocity of its center of mass ($\vec{v}_{OSi}$) as a function of the minimal coordinates using Euler's differentiation rule on $\vec{r}_{OSi}$
	\item Calculate the translational jacobian matrix $J_{Si}$ by taking the partial derivative of $\vec{v}_{OSi}$ with respect to the velocity states
	\item Calculate the rotational jacobian matrix $J_{Ri}$ by taking the partial derivative of $\vec{\omega}_i$ with respect to the velocity states
	\item Calculate the derivative of the impulse $\vec{p}_{i} = m_i \cdot \vec{v}_{OSi}$
	\item Calculate the derivative of the spin $\vec{N}_{Si} = \theta_i \cdot \vec{\Omega}_{i}$
\end{enumerate}
Note that after formulating the first two items plus the rolling constraints to eliminate non-minimal coordinates, everything can be calculated (using a computer and a symbolic math library, e.g. sympy). The detailed individual steps for those calculations are therefore omitted.
The projected Newton-Euler equations are then given by:
\begin{equation}
0 = \sum_{i=1}^n \left[{}_I J_{Si} \cdot \left( {}_I \left(\dot{\vec{p}}_i \right) - {}_I \vec{F}_i \right) + {}_I J_{Ri} \cdot \left( {}_I \left(\dot{\vec{N}}_{Si} \right) - {}_I \vec{M}_i \right) \right]
\end{equation}
This leads to three equations in the form $A \cdot [\ddot{\beta}, \ddot{\varphi}, \ddot{\psi}] = b$ where
\begin{align*}
A[0,0] &= \theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 \\
A[0,1] &= l \cdot m_3 \cdot r_2 \cdot cos(\varphi) \\
A[0,2] &= -r_2 \cdot (r_1 + r_2) \cdot (\theta_1/r_1^2  + m_1 + (m_2+m_3) \cdot (1+cos(\psi)))\\
A[1,0] &= A[0,1] \\
A[1,1] &= \theta_3 + l^2 \cdot m_3 \\
A[1,2] &= -l \cdot m_3 \cdot (r_1 + r_2) \cdot (cos(\varphi) + cos(\psi - \varphi)) \\
A[2,0] &= A[0,2] \\
A[2,1] &= A[1,2] \\
A[2,2] &= (r_1 + r_2)^2 \cdot (\theta_1/r_1^2 + m_1 + 2 \cdot (m_2+m_3) \cdot (1+cos(\psi))) \\
b[0] &= -T - \dot{\psi}^2 \cdot (m_2+m_3) \cdot r_2 \cdot (r_1 + r_2) \cdot sin(\psi) + m_3 \cdot r_2 \cdot  \dot{\varphi}^2 \cdot l \cdot sin(\varphi) \\
b[1] &= T - \dot{\psi}^2 \cdot l \cdot m_3 \cdot (r_1+r_2) \cdot sin(\psi - \varphi) - g \cdot l \cdot m_3 \cdot sin(\varphi) \\
b[2] &= (r_1 + r_2) \cdot (m_2+m_3) \cdot sin(\psi) \cdot ((r_1 + r_2) \cdot \dot{\psi}^2 + g) \\
&\qquad +(r_1 + r_2) \cdot \dot{\varphi}^2 \cdot l \cdot m_3 \cdot (sin(\psi - \varphi)-sin(\varphi)) \\
\end{align*}

\subsection{Incorporating motor dynamics into the equations of motion}
\label{ss:EoM}
While applying torque is the most direct way to control above system, the ability to control the torque directly imposes some strong mechanical requirements: 
A torque-controlled motor with a very high torque has to be used and the lever arm needs to be able to swing freely when the motor is off (no gearbox / low friction in general).
A much simpler approach is controlling the velocity of a (DC)-motor with a gearbox and encoder instead. The simplest viable (requiring finite torques) model of a speed-controlled motor is a first order system, where the motor speed $\dot{\varphi}_m$ follows the speed command $\breve{\dot{\varphi}}_m$ with time constant $\tau_m$:
\begin{equation}
\ddot{\varphi}_m = \frac{1}{\tau_m} \cdot \left(\breve{\dot{\varphi}}_m - \dot{\varphi}_m \right)
\label{eq:motordyn}
\end{equation} 
In order to incorporate this motor model into the equations of motion, the torque $T$ has to be eliminated from the equations of motion, and the motor dynamics have to be expressed in the minimal coordinates to replace the eliminated equation.
By inspecting the $b[0]$ and $b[1]$ terms, it can be immediately seen that $T$ can be eliminated by adding the first two equations. 
The relation between the motor dynamics and the minimal coordinates is $\beta + \varphi_m = \varphi$, and consequently $\varphi_m = \varphi - \beta$, $\dot{\varphi}_m = \dot{\varphi} - \dot{\beta}$ and $\ddot{\varphi}_m = \ddot{\varphi} - \ddot{\beta}$.
Substituting back these expressions into eq. \ref{eq:motordyn}, we get:
\begin{equation}
\ddot{\varphi} - \ddot{\beta} = \frac{1}{\tau_m} \cdot \left(\breve{\dot{\varphi}}_m - \dot{\varphi} + \dot{\beta} \right)
\end{equation}
With those substitutions, the three equations $A \cdot [\ddot{\beta}, \ddot{\varphi}, \ddot{\psi}] = b$ become
\begin{align*}
A[0,0] &= \theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 + l \cdot m_3 \cdot r_2 \cdot cos(\varphi)\\
A[0,1] &= l \cdot m_3 \cdot r_2 \cdot cos(\varphi) + \theta_3 + l^2 \cdot m_3 \\
A[0,2] &= -r_2 \cdot (r_1 + r_2) \cdot (\theta_1/r_1^2  + m_1 + (m_2+m_3) \cdot (1+cos(\psi))) \\
&\qquad -l \cdot m_3 \cdot (r_1 + r_2) \cdot (cos(\varphi) + cos(\psi - \varphi)) \\
A[1,0] &= -1 \\
A[1,1] &= 1 \\
A[1,2] &= 0 \\
A[2,0] &= -r_2 \cdot (r_1 + r_2) \cdot (\theta_1/r_1^2  + m_1 + (m_2+m_3) \cdot (1+cos(\psi))) \\
A[2,1] &= -l \cdot m_3 \cdot (r_1 + r_2) \cdot (cos(\varphi) + cos(\psi - \varphi)) \\
A[2,2] &= (r_1 + r_2)^2 \cdot (\theta_1/r_1^2 + m_1 + 2 \cdot (m_2+m_3) \cdot (1+cos(\psi))) \\
b[0] &= - \dot{\psi}^2 \cdot (r_1 + r_2) \cdot ( r_2 \cdot (m_2+m_3) \cdot sin(\psi) +  l \cdot m_3 \cdot sin(\psi - \varphi)) \\
&\qquad  + l \cdot m_3 \cdot sin(\varphi) \cdot (r_2 \cdot  \dot{\varphi}^2 - g) \\
b[1] &= 1/\tau_m \cdot (\dot{\beta} - \dot{\varphi} + \breve{\dot{\varphi}}_m) \\
b[2] &= (r_1 + r_2) \cdot (m_2+m_3) \cdot sin(\psi) \cdot ((r_1 + r_2) \cdot \dot{\psi}^2 + g) \\
&\qquad +(r_1 + r_2) \cdot \dot{\varphi}^2 \cdot l \cdot m_3 \cdot (sin(\psi - \varphi)-sin(\varphi)) \\
\end{align*}

\subsection{System analysis}
\label{ss:systemanalysis}
This subsection's purpose is to improve the overall understanding of the system.
The mathematical analysis will further illustrate the basic working principle of the system:
\begin{itemize}
	\item Accelerate the upper (and lower) ball $\ddot{\beta}$ by keeping the upper ball at a certain angle deflection $\psi$ on top of the lower ball (control $\ddot{\beta}$ through $\psi$)
	\item Keep pointing the lever arm opposite to the $\psi$ deflection to prevent the upper ball from rolling off (control $\ddot{\psi}$ through $\varphi$)
	\item Send motor commands $\breve{\dot{\varphi}}_m$ to change the orientation of the lever arm $\varphi$ (control $\ddot{\varphi}$ through $\breve{\dot{\varphi}}_m$)
\end{itemize}
In order to show that there are $\varphi$ / $\psi$ constellations which result in constant $\ddot{\beta}$ acceleration of the ball, the non-linear equations of motion are evaluated at $\varphi = const$ and $\psi = const$, which implies $\dot{\varphi} = \ddot{\varphi} = \dot{\psi} = \ddot{\psi} = 0$.
This results in the following three equations:
\begin{align}
0 &= \left(\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 + l \cdot m_3 \cdot r_2 \cdot cos(\varphi) \right) \cdot \ddot{\beta}  \nonumber \\
&\qquad  + l \cdot m_3 \cdot g \cdot sin(\varphi) \label{eq:phi_betaddot_relation} \\
0 &= \ddot{\beta} + 1/\tau_m \cdot (\dot{\beta} + \breve{\dot{\varphi}}_m) \\
0 &= (\theta_1/r_1^2  + m_1 + (m_2+m_3) \cdot (1+cos(\psi))) \cdot r_2 \cdot \ddot{\beta} + (m_2+m_3) \cdot g \cdot sin(\psi)
\label{eq:psi_betaddot_relation}
\end{align}
The first equation shows how far out the lever arm has to be rotated to balance under constant acceleration $\ddot{\beta}$.
The second equation shows how the motor command $\breve{\dot{\varphi}}_m$ has to be selected to keep the $\ddot{\beta}$ acceleration constant, namely $\breve{\dot{\varphi}}_m = -\dot{\beta} - \tau_m \cdot \ddot{\beta}$.
The third equation shows how large the $\ddot{\beta}$ acceleration is when keeping the ball at a certain $\psi$ angle.

Intuitively, one can tell that the limiting factor in this system is the lever arm; keeping it at $\pm \pi/2$ is basically the maximum effort that can be put in to recover the system.
The exact value can be found by solving the first equation for $\ddot{\beta}$ and setting its derivative wrt. $\varphi$ to 0:
\begin{equation}
\label{eq:beta_ddot_vs_phi}
\ddot{\beta}(\varphi) = \frac{-l \cdot m_3 \cdot g \cdot sin(\varphi)}{\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 + l \cdot m_3 \cdot r_2 \cdot cos(\varphi)} = \frac{g(\varphi)}{h(\varphi)}
\end{equation}
For a function $f(x)$ in the form of $f(x) = g(x)/h(x)$, its derivative is given as $\frac{\partial f(x)}{\partial x} = f'(x) = \frac{g'(x) \cdot h(x) - h'(x) \cdot g(x)}{h(x)^2}$, hence the extrema $x^*$ are where $g'(x) \cdot h(x) - h'(x) \cdot g(x) \Big|_{x=x^*} = 0$.
\begin{align*}
0 = {}& \frac{\partial \ddot{\beta}(\varphi)}{\partial \varphi} \Big|_{\varphi=\varphi_{max}} = \frac{\partial g(\varphi)}{\partial \varphi} \cdot h(\varphi) - g(\varphi) \cdot \frac{\partial h(\varphi)}{\partial \varphi} \Big|_{\varphi=\varphi_{max}} \\
= {}& -l \cdot m_3 \cdot g \cdot l \cdot m_3 \cdot r_2 \cdot \left(cos(\varphi_{max})^2 + sin(\varphi_{max})^2 \right) \\
{}& -l \cdot m_3 \cdot g \cdot cos(\varphi_{max}) \cdot \left(\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 \right)
\end{align*}
Since $cos(\varphi)^2 + sin(\varphi)^2 = 1$, this equation can be reformulated to:
\begin{equation*}
cos(\varphi_{max}) \cdot \left(\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 \right) = -l \cdot m_3 \cdot r_2
\end{equation*}
resulting in the following equation for $\varphi_{max}$:
\begin{equation}
\varphi_{max} = \arccos{ \left( \frac{-l \cdot m_3 \cdot r_2}{\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2} \right) }
\label{eq:phi_max}
\end{equation}
This corresponds to the previous statement about keeping the lever arm at about $\pm \pi/2$ during maximum acceleration $\ddot{\beta}$;
the right hand side is some small negative value, hence the absolute value of $\varphi$ has to be just slightly above $\pi/2$ during maximum acceleration $\ddot{\beta}$.
The maximum acceleration $\ddot{\beta}_{max}$ can be well approximated by setting $\varphi = -\pi/2$ in eq. \ref{eq:beta_ddot_vs_phi}:
\begin{equation}
\ddot{\beta}_{max} \approx \frac{l \cdot m_3 \cdot g}{\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2}
\label{eq:beta_ddot_max}
\end{equation}
It can be shown that angle $\varphi$ of the lever arm is the limiting factor for $\ddot{\beta}$ accelerations, and not the upper ball falling off the lower ball at $\psi = \pm \pi/2$, by solving the third equation for $\ddot{\beta}$ and inserting $\psi = -\pi/2$:
\begin{align*}
\ddot{\beta}(\psi=-\pi/2) &= -\frac{(m_2+m_3) \cdot g \cdot sin(\psi)}{(\theta_1/r_1^2  + m_1 + (m_2+m_3) \cdot (1+cos(\psi))) \cdot r_2} \Big|_{\psi=\pi/2} \\
&= \frac{(m_2+m_3) \cdot g}{(\theta_1/r_1^2  + m_1 + m_2 + m_3) \cdot r_2} \\
&> \frac{m_3 \cdot g}{(\theta_1/r_1^2  + m_1 + m_2 + m_3) \cdot r_2} \\
&= \frac{m_3 \cdot g \cdot r_2}{(\theta_1/r_1^2  + m_1 + m_2 + m_3) \cdot r_2^2} \\
&> \frac{m_3 \cdot g \cdot l}{(\theta_1/r_1^2  + m_1 + m_2 + m_3) \cdot r_2^2} \\
&> \frac{m_3 \cdot g \cdot l}{(\theta_1/r_1^2 + \theta_2/r_2^2 + m_1 + m_2 + m_3) \cdot r_2^2} \\
&\approx \ddot{\beta}_{max}
\end{align*}
That means that the upper ball is kept at some angle $|\psi|<\pi/2$ at maximum acceleration $\ddot{\beta}_{max}$ limited by the lever arm angle $\varphi$.
Generally, for any feasible acceleration $\ddot{\beta}$, angle $\psi$ can be calculated by solving the third equation for it:
\begin{align}
(m_2+m_3) \cdot (1+cos(\psi)) \cdot \ddot{\beta} + \frac{(m_2+m_3) \cdot g}{r_2} \cdot sin(\psi) = -(\theta_1/r_1^2  + m_1) \cdot \ddot{\beta} \nonumber \\
\rightarrow \ddot{\beta} \cdot cos(\psi) + \frac{g}{r_2} \cdot sin(\psi) = -\frac{\theta_1/r_1^2  + m_1}{m_2+m_3} \cdot \ddot{\beta} - \ddot{\beta} \nonumber \\
\rightarrow \sqrt{\ddot{\beta}^2 + \frac{g^2}{r_2^2}} \sin{\left( \psi + \arctan{\left( \frac{r_2 \cdot \ddot{\beta}}{g}\right)}\right)} = -\left( 1 + \frac{\theta_1/r_1^2  + m_1}{m_2+m_3} \right) \cdot \ddot{\beta} \nonumber \\
\rightarrow \psi = - \arctan{\left( \frac{r_2 \cdot \ddot{\beta}}{g}\right)} -\arcsin{\left(\left( 1 + \frac{\theta_1/r_1^2  + m_1}{m_2+m_3} \right) \cdot \frac{\ddot{\beta}}{\sqrt{\ddot{\beta}^2 + \frac{g^2}{r_2^2}}} \right)}
\label{eq:psi_vs_beta_ddot}
\end{align}
using $a \cdot \sin{x} + b \cdot \cos {x} = \sqrt{a^2+b^2} \cdot \sin{\left(x+\arctan{\left(b/a\right)} \right)} \cite{trigsimpl}$.
For later purposes, we'll solve eq. \ref{eq:psi_betaddot_relation} for $\ddot{\beta}$:
\begin{align}
0 &= (\theta_1/r_1^2  + m_1 + (m_2+m_3) \cdot (1+cos(\psi))) \cdot r_2 \cdot \ddot{\beta} + (m_2+m_3) \cdot g \cdot sin(\psi) \nonumber \\
\rightarrow \ddot{\beta} &= \frac{-(m_2+m_3) \cdot g \cdot sin(\psi) }{(\theta_1/r_1^2  + m_1 + (m_2+m_3) \cdot (1+cos(\psi))) \cdot r_2}
\label{eq:beta_ddot_vs_psi}
\end{align}
and eq. \ref{eq:phi_betaddot_relation} for $\varphi$ instead:
\begin{align}
0 = \left(\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 + l \cdot m_3 \cdot r_2 \cdot cos(\varphi) \right) \cdot \ddot{\beta}  \nonumber \\
\qquad  + l \cdot m_3 \cdot g \cdot sin(\varphi) \nonumber \\
\rightarrow  g \cdot sin(\varphi) + r_2 \cdot \ddot{\beta} \cdot cos(\varphi) = -\frac{\left(\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 \right) \cdot \ddot{\beta} }{l \cdot m_3} \nonumber \\
\rightarrow \sin{\left( \varphi + \arctan{\left( \frac{r_2 \cdot \ddot{\beta}}{g}\right)} \right)} = -\frac{\left(\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 \right) \cdot \ddot{\beta} }{l \cdot m_3 \cdot \sqrt{g^2 + r_2^2 \ddot{\beta}^2}} \nonumber \\
\rightarrow \varphi = -\arctan{\left( \frac{r_2 \cdot \ddot{\beta}}{g}\right)} - \arcsin{\left( \frac{\theta_1 \cdot r_2^2/r_1^2 + \theta_2 + (m_1 + m_2 + m_3) \cdot r_2^2 }{l \cdot m_3 \cdot \sqrt{r_2^2 + \frac{g^2}{\ddot{\beta}^2}}} \right)}
\label{eq:phi_vs_beta_ddot}
\end{align}

\subsection{Controller derivation}

\subsubsection{System Linearization}
\label{ss:syslin}
A lot of concepts in control theory are based on linear systems of the form $\dot{x} = A \cdot x + B \cdot u$, where $A$ and $B$ are matrices that are just a function of system parameters (and potentially time), but not states.
In order stabilize a non-linear systems, the system is linearized about its equilibrium.
The concepts based on linear systems then work perfectly for infinitesimal deflections from the equilibrium, but fail further away from the equilibrium where the non-linear system behaves significantly different compared to its linearized version.

The equilibrium of the system $(x^*, u^*)$ is at $\varphi^* = \psi^* = \dot{\beta}^* = \dot{\varphi}^* = \dot{\psi}^* = \breve{\dot{\varphi}}_m^* = 0$, and $\beta^*$ arbitrary\footnote{
There is another equilibrium with the lever arm pointing up ($\dot{\varphi} = \pi$), which is much harder to control and not considered for now. Additionally, there are two equilibriums with the upper ball below the ground at $\psi = \pi$.}.

Linearizing $A \cdot [\ddot{\beta}, \ddot{\varphi}, \ddot{\psi}] = b$ from subsec. \ref{ss:EoM} around the equilibrium results in
\begin{equation}
M \cdot \left( {\begin{array}{c} \ddot{\beta} \\ \ddot{\varphi} \\ \ddot{\psi} \\ \end{array} } \right) +
D \cdot \left( {\begin{array}{c} \dot{\beta} \\ \dot{\varphi} \\ \dot{\psi} \\ \end{array} } \right) +
K \cdot \left( {\begin{array}{c} \beta \\ \varphi \\ \psi \\ \end{array} } \right) =
F \cdot \breve{\dot{\varphi}}_m
\end{equation}
where
\begin{itemize}
	\item $M = \frac{\partial \left(A \cdot [\ddot{\beta}, \ddot{\varphi}, \ddot{\psi}] \right)}{\partial [\ddot{\beta}, \ddot{\varphi}, \ddot{\psi}]} = A\Big|_{x=x^*}$
	\item $D = -\frac{\partial b}{\partial [\dot{\beta}, \dot{\varphi}, \dot{\psi}]}\Big|_{x=x^*}$
	\item $K = -\frac{\partial b}{\partial [\beta, \varphi, \psi]}\Big|_{x=x^*}$
	\item $F = \frac{\partial b}{\partial \breve{\dot{\varphi}}_m}\Big|_{x=x^*}$
\end{itemize}
This system of three second order differential equations can be transformed into six equations of first order $\dot{x} = A \cdot x + B \cdot u$ by using:
\begin{itemize}
	\item state $x = [\beta, \varphi, \psi, \dot{\beta}, \dot{\varphi}, \dot{\psi}]$
	\item input $u = \breve{\dot{\varphi}}_m$
	\item system matrix $A = \left( {\begin{array}{cc} 0_{3 \times 3} & I_{3 \times 3} \\ -M^{-1} \cdot K & -M^{-1} \cdot D  \end{array} } \right)$
	\item control matrix $B = \left( {\begin{array}{c} 0_{3 \times 1} \\ M^{-1} \cdot F \end{array} } \right)$
\end{itemize}
Evaluating the expressions for $M$, $D$, $K$ and $F$ results in
\begin{align*}
M[0,0] &= \theta_1 \cdot r_2^2/r_1^2 + \theta_2 + l \cdot m_3 \cdot r_2 + (m_1 + m_2 + m_3) \cdot r_2^2  \\
M[0,1] &= \theta_3 + l^2 \cdot m_3 + l \cdot m_3 \cdot r_2  \\
M[0,2] &= -(r_1 + r_2) \cdot (\theta_1 \cdot r_2 /r_1^2 + 2 \cdot l \cdot m_3 + m_1 \cdot r_2 + 2 \cdot m_2 \cdot r_2 + 2 \cdot m_3 \cdot r_2)  \\
M[1,0] &= -1 \\
M[1,1] &= 1 \\
M[1,2] &= 0 \\
M[2,0] &= -r_2 \cdot (r_1 + r_2) \cdot (\theta_1/r_1^2  + m_1 + 2 \cdot m_2 + 2 \cdot m_3) \\
M[2,1] &= -2 \cdot l \cdot m_3 \cdot (r_1 + r_2) \\
M[2,2] &= (r_1 + r_2)^2 \cdot (\theta_1/r_1^2 + m_1 + 4 \cdot m_2 + 4 \cdot m_3) \\
D &= \left( {\begin{array}{ccc}
0 & 0 & 0 \\
-1/\tau & 1/\tau & 0 \\
0 & 0 & 0 \end{array} } \right) \\
K &= \left( {\begin{array}{ccc}
0 & g \cdot l \cdot m_3 & 0 \\
0 & 0 & 0 \\
0 & 0 & -g \cdot (m_2 + m_3) \cdot (r_1 + r_2)  \end{array} } \right) \\
F &= \left( {\begin{array}{c} 0 \\ 1/\tau \\ 0 \end{array} } \right)
\end{align*}

\subsubsection{LQ-Regulator}
\label{ss:lqr}
Very little understanding of control theory is required to stabilize a system using the Linear-quadratic regulator (LQR):
Given the dynamics of the system $\dot{x} = A \cdot x + B \cdot u$, one can select martices $R$ and $Q$, which results in a linear control law $u = -K \cdot x$ minimizing the cost $J = \int_0^{\infty} x^T \cdot Q \cdot x + u^T \cdot R \cdot u \, \mathrm{d}t$.
The matrices $Q$ and $R$ are usually picked to be diagonal for simplicity.
In order to pick $Q$ and $R$ to achieve a smooth and fast response, the following rules of thumb apply:
\begin{itemize}
	\item Reducing $R$ will allow larger input signals and therefore make the controller more aggressive
	\item Increasing a $Q$ entry will result in a more aggressive behavior to reduce the corresponding state error.
	In our specific system, increasing $Q$ entries corresponding to angular states will make the system move faster to reduce these errors and cause oscillatory behavior, whereas increasing $Q$ entries corresponding to angular velocity will make the system move slower and hence dampen the system to reduce oscillations.
	\item Lastly note that the weights are relative, i.e. scaling all entries by the same (positive) number leads to the same result.
\end{itemize}
After deriving $A$ and $B$ and selecting $Q$ and $R$, the state feedback matrix $K$ can be calculated by solving the algebraic Riccati equation for $P$
\begin{equation}
P \cdot A + A^T \cdot P - P \cdot B \cdot R^{-1} \cdot B^T \cdot P + Q = 0
\label{eq:lqrP}
\end{equation}
and then calculating
\begin{equation}
K = R^{-1} \cdot B^T \cdot P
\label{eq:lqrK}
\end{equation}
Theoretically, selecting any combination of positive diagonal entries in $Q$ and $R$ will result in a solution $K$ that stabilizes the system.
In practice however, there are some limitations; mainly that an overly aggressive controller with make the system unstable due to:
\begin{itemize}
	\item Delays: There will be time delays in the chain of change of state, observing this change with sensors, computing a command and the actuator starting to move according to the computed command.
	\item Discrete Time Control: The frequency at which a digital controller runs is limited. This is not a problem though as long as this frequency is significantly faster than the system dynamics; and if that's not the case, this problem can be circumvented by discretizing the system and applying the discrete time LQR solution.
	\item Imperfect state information / sensor noise: Above formulation assumes perfect state information; sensor noise will cause noise in the estimated state, which will be directly amplified to jitter in the command.
	\item Model imperfections: In general, ''all models are wrong``.
	Unmodelled / non-linear effects such as friction / slippage / elastic deformations / play and inaccurately measured physical parameters can make the system behave differently than intended.
\end{itemize}

\subsubsection{Pole Placement}
Alternatively to using the LQR method, the state feedback matrix $K$ can be designed by analyzing the poles of the closed-loop system:
Inserting the control law $u = -K \cdot x$ into the open-loop dynamics of the system $\dot{x} = A \cdot x + B \cdot u$ results in the closed-loop dynamics
\begin{equation}
\dot{x} = A \cdot x + B \cdot u = A \cdot x - B \cdot K \cdot x = (A - B \cdot K) \cdot x
\end{equation}
The poles of the closed-loop system are therefore the eigenvalues of $(A - B \cdot K)$:
In a nutshell, one can calculate the characteristic polynomial $\lambda^n + a_{n-1} \cdot \lambda^{n-1} + ... + a_1  \cdot \lambda + a_0 = 0$ where $a_i$ are functions of $K$ entries.
One can then expand the polynomial $(\lambda-\lambda_1) \cdot (\lambda-\lambda_2) \cdot ... \cdot (\lambda-\lambda_n)$ where $\lambda_i$ are the desired eigenvalues and equate the coefficients with the ones of the characteristic polynomial, which will give equations that can be solved for the $K$ entries.

\subsubsection{Linear stabilizing controller}
As the first controller version, the LQR approach is used to stabilize the system at an arbitrary position $\beta$:
Using the system matrices $A$ and $B$ derived in subsec. \ref{ss:syslin}, picking $Q = diag \left( \left[0, q_{\varphi}, q_{\psi}, q_{\dot{\beta}}, q_{\dot{\varphi}}, q_{\dot{\psi}} \right] \right)$ and $R = r_{\breve{\dot{\varphi}}_m}$, eq. \ref{eq:lqrP} can be solved for $P$, which subsequently is inserted into eq.\ref{eq:lqrK}, resulting in $K = \left[0, k_{\varphi}, k_{\psi}, k_{\dot{\beta}}, k_{\dot{\varphi}}, k_{\dot{\psi}} \right]$. The system can be stabilized for a small initial deflection from the equilibrium using the control law $u=\breve{\dot{\varphi}}_m=-K \cdot x$.

\subsubsection{Linear $\dot{\beta}$ controller}
Next, we add the capability of moving (rotating) the upper ball at a certain constant velocity $\breve{\dot{\beta}}$, while of course balancing on the lower ball.
Intuitively, one can say that while the upper ball is rotating at $\breve{\dot{\beta}}$, the lever arm needs to keep pointing down, which is achieved by rotating the motor into the opposite direction $\dot{\varphi}_m = -\breve{\dot{\beta}}$, for which the motor has to be commanded to rotate at
\begin{equation}
\breve{\dot{\varphi}}_m = -\breve{\dot{\beta}}
\label{eq:ssmcmd}
\end{equation}
It can be most easily verified using the non-linear equations $A \cdot [\ddot{\beta}, \ddot{\varphi}, \ddot{\psi}] = b$ in sec. \ref{ss:EoM} that state $x = [\beta(t), 0, 0, \breve{\dot{\beta}}, 0, 0]$ with command $\breve{\dot{\varphi}}_m = -\breve{\dot{\beta}}$ leads to an un-accelerated motion since $b=0$.
In order to make the ball accelerate when being at equilibrium $x=[0,0,0,0,0,0]$, a feed-forward part $u_{ff} \left( \breve{\dot{\beta}} \right)$ has to be added to the control law: .
\begin{equation}
\breve{\dot{\varphi}}_m=-K \cdot x + u_{ff}
\label{eq:ffwdmcmd}
\end{equation}
Inserting eq. \ref{eq:ssmcmd}, state $x = [\beta(t), 0, 0, \breve{\dot{\beta}}, 0, 0]$ and feedback gain \newline $K = \left[0, k_{\varphi}, k_{\psi}, k_{\dot{\beta}}, k_{\dot{\varphi}}, k_{\dot{\psi}} \right]$ into eq. \ref{eq:ffwdmcmd} results in
\begin{equation}
-\breve{\dot{\beta}} = -k_{\dot{\beta}} \cdot \breve{\dot{\beta}}  + u_{ff}
\end{equation}
which can be solved for the feed-forward part $u_{ff} = (k_{\dot{\beta}} - 1 ) \cdot \breve{\dot{\beta}}$ and inserted into the control law:
\begin{equation}
\breve{\dot{\varphi}}_m=-K \cdot x + \left(k_{\dot{\beta}} - 1 \right) \cdot \breve{\dot{\beta}}
\label{eq:betadotctrl}
\end{equation}
With this controller, the system can be controlled to desired $\breve{\dot{\beta}}$ velocities.
There is a caveat though: Large $\breve{\dot{\beta}}$ commands will make the upper ball fall off the lower ball.
The easiest measure to prevent this is saturating the input, i.e. limiting the absolute value of $\breve{\dot{\beta}}$ to $\breve{\dot{\beta}}_{max}$.
We'll not explore better alternatives at this point, since limiting $\breve{\dot{\beta}}$ is a workaround:
The system (at least the mathematical model) has no inherent $\dot{\beta}$ limitation, we are simply indirectly limiting the $\ddot{\beta}$ acceleration to not hit the $\ddot{\beta}_{max}$ limit (see eq. \ref{eq:beta_ddot_max}).

\subsubsection{Linear $\beta$ controller}

Through the $\dot{\beta}$ controller in the previous subsection, $\beta$ can be controlled using a classical PI-controller of the form
\begin{equation}
\breve{\dot{\beta}} = \frac{1}{\tau_{\beta}} \cdot \left( \breve{\beta} - \beta \right) - k_d \cdot \dot{\beta}
\label{eq:betactrl}
\end{equation}
where $\tau_{\beta}$ is the time-constant (inverse of the proportional gain) limited by the reactiveness of the $\dot{\beta}$ controller, and $k_d$ the derivative gain for dampening the response.

\subsubsection{Stacked $\dot{\beta}$ controller}

In the subsections above, a controller structure (eqs. \ref{eq:betactrl}, \ref{eq:betadotctrl}) has been derived that can control the ball to go to any position $\beta$.
However, along the way a $\breve{\dot{\beta}}$ limitation was introduced, to indirectly prevent the upper ball from falling off the lower one.
As mentioned above, the system does not have an inherent $\dot{\beta}$ limitation, so this $\breve{\dot{\beta}}$ limitation prevents us from fully exploiting the systems' capabilities, which is why we want to get rid of it.
Instead, the actual limitations of the system have to be addressed directly.
In the system analysis (subsec. \ref{ss:systemanalysis}), we saw that:
\begin{itemize}
	\item Acceleration $\ddot{\beta}$ is limited to some value $\ddot{\beta}_{max}$ (eq. \ref{eq:beta_ddot_max})
	\item Lever arm angle $\varphi$ should be limited to approximately $[-\pi/2, \pi/2]$ (eq. \ref{eq:phi_max})
\end{itemize}
However, these limitations can't just be inserted into the $\dot{\beta}$ controller.
Therefore, the $\dot{\beta}$ controller is first reformulated into a mathematically equivalent cascade of controllers:
Note that there is already a separation into a $\beta$ and $\dot{\beta}$ controller, which allowed to limit $\breve{\dot{\beta}}$ commands;
further separation will allow to limit $\breve{\ddot{\beta}}$ and $\breve{\varphi}$.
First, recall the structure of the $\dot{\beta}$ controller:
\begin{equation}
\breve{\dot{\varphi}}_m=- k_{\varphi} \varphi - k_{\psi}\psi - k_{\dot{\beta}}\dot{\beta} - k_{\dot{\varphi}} \dot{\varphi} - k_{\dot{\psi}} \dot{\psi} + \left(k_{\dot{\beta}} - 1 \right) \cdot \breve{\dot{\beta}}
\label{eq:betadotctrl2}
\end{equation}
We'll work our way up from the lowest level controller, the $\dot{\varphi}$ controller:
Since the motor is fixed to the upper ball and the lever arm, $\dot{\varphi} = \dot{\varphi}_m + \dot{\beta}$, so to control $\dot{\varphi}$, we use:
\begin{equation}
\breve{\dot{\varphi}}_m = \breve{\dot{\varphi}} - \dot{\beta}
\end{equation}
Next, $\breve{\dot{\varphi}}$ is the output of a $\varphi$ PD-controller:
\begin{equation}
\breve{\dot{\varphi}} = k_{\varphi} \cdot \left( \breve{\varphi} - \varphi \right) - k_{\dot{\varphi}} \dot{\varphi}
\end{equation}
A PD controller controls $\psi$ through commanding the lever arm angle $\breve{\varphi}$:
\begin{equation}
\breve{\varphi} =  \frac{k_{\psi}}{k_{\varphi}}  \cdot \left( \breve{\psi} - \psi \right) - \frac{k_{\dot{\psi}}}{k_{\varphi}} \cdot \dot{\psi}
\end{equation}
Lastly, changes of $\dot{\beta}$ (which is $\ddot{\beta}$) is controlled through $\breve{\psi}$:
\begin{equation}
\breve{\psi} = \frac{k_{\dot{\beta}} - 1}{k_{\psi}}  \cdot \left( \breve{\dot{\beta}} - \dot{\beta} \right)
\end{equation}
Note that:
\begin{itemize}
	\item The gain from $\dot{\varphi} \rightarrow \breve{\dot{\varphi}} \rightarrow \breve{\dot{\varphi}}_m$ is $-k_{\dot{\varphi}} \cdot 1 = -k_{\dot{\varphi}}$
	\item The gain from $\varphi \rightarrow \breve{\dot{\varphi}} \rightarrow \breve{\dot{\varphi}}_m$ is $-k_{\varphi} \cdot 1 = -k_{\varphi}$
	\item The gain from $\dot{\psi} \rightarrow \breve{\varphi} \rightarrow \breve{\dot{\varphi}} \rightarrow \breve{\dot{\varphi}}_m$ is $-\frac{k_{\dot{\psi}}}{k_{\varphi}} \cdot k_{\varphi} \cdot 1 = -k_{\dot{\psi}}$
	\item The gain from $\psi \rightarrow \breve{\varphi} \rightarrow \breve{\dot{\varphi}} \rightarrow \breve{\dot{\varphi}}_m$ is $-\frac{k_{\psi}}{k_{\varphi}} \cdot k_{\varphi} \cdot 1 = -k_{\psi}$
	\item The gain from $\dot{\beta} \rightarrow \breve{\psi} \rightarrow \breve{\varphi} \rightarrow \breve{\dot{\varphi}} \rightarrow \breve{\dot{\varphi}}_m$ is $-\frac{k_{\dot{\beta}} - 1}{k_{\psi}} \cdot \frac{k_{\psi}}{k_{\varphi}} \cdot k_{\varphi} \cdot 1 - 1 = -k_{\dot{\beta}}$
  \item The gain from $\breve{\dot{\beta}} \rightarrow \breve{\psi} \rightarrow \breve{\varphi} \rightarrow \breve{\dot{\varphi}} \rightarrow \breve{\dot{\varphi}}_m$ is $\frac{k_{\dot{\beta}} - 1}{k_{\psi}} \cdot \frac{k_{\psi}}{k_{\varphi}} \cdot k_{\varphi} \cdot 1= k_{\dot{\beta}} - 1$
\end{itemize}
as in eq. \ref{eq:betadotctrl2}, which means that this is indeed a mathematically equivalent formulation.

\subsubsection{Non-linear stacked  $\dot{\beta}$ controller}

A crucial step towards a controller that properly handles the system's limitations is incorporating the results of the system analysis in subsec. \ref{ss:systemanalysis}.
The $\dot{\beta}$ controller stack consists of the following structure:
\begin{itemize}
	\item{$\dot{\beta}$ controller: $\breve{\ddot{\beta}} = k_{\dot{\beta}} \cdot \left( \breve{\dot{\beta}} - \dot{\beta} \right)$}
	\item{Convert $\breve{\ddot{\beta}}$ to $\breve{\psi}$ using eq. \ref{eq:psi_vs_beta_ddot}}
	\item{Clip $\breve{\psi}$ to some magnitude $\breve{\psi}_{max}$. This value should be below the theoretical maximum to account for potential overshoot of underlying controllers, reactivity (controller margin), controller imperfections etc. (ignoring additional real-world considerations here)}
  \item{To stabilize the upper ball at current angle $\psi$, calculate a feed-forward part $\breve{\varphi}_{ff}$ by inserting $\psi$ into eq. \ref{eq:beta_ddot_vs_psi}, and the resulting $\ddot{\beta}$ into eq. \ref{eq:phi_vs_beta_ddot}}
  \item{Correct additional errors from $\breve{\psi}$ using a PD controller: $\Delta \breve{\varphi} =  k_{\psi} \cdot \left( \breve{\psi} - \psi \right) - k_{\dot{\psi}} \cdot \dot{\psi} $}
	\item{The total $\varphi$ command is then: $\breve{\varphi} = \Delta \breve{\varphi} + \breve{\varphi}_{ff} $}
  \item{Clip $\breve{\varphi}$ to magnitude $\varphi_{max}$ from eq. \ref{eq:phi_max}}
	\item{Control $\breve{\varphi}$ using a PD controller: $\breve{\dot{\varphi}} = k_{\varphi} \cdot \left( \breve{\varphi} - \varphi \right) - k_{\dot{\varphi}} \dot{\varphi}$}
	\item{As above, set the motor command to $\breve{\dot{\varphi}}_m = \breve{\dot{\varphi}} - \dot{\beta}$}
\end{itemize}
Similarly to above subsection, each gain of this new structure can be set such that a change of state $\delta x$ leads to the same change in output $\breve{\dot{\varphi}}$ as before the reformulation.
Note that since above controller is non-linear, this only applies for infinitesimal deflections from the equilibrium.

\begin{thebibliography}{1}

\bibitem{trigsimpl} \href{https://en.wikibooks.org/wiki/Trigonometry/Simplifying_a_sin(x)_+_b_cos(x)}{Wikibooks: Trigonometry/Simplifying a sin(x) + b cos(x)}

\end{thebibliography}

\end{document}